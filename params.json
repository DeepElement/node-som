{"name":"Node-som","tagline":"A Kohonen Network api for Node\"","body":"A Kohonen Network api for NodeJS\r\n=====================================================\r\n[![npm status](https://nodei.co/npm/node-som.png?compact=true)](https://nodei.co/npm/node-som.png?compact=true)\r\n[![Build Status](https://travis-ci.org/DeepElement/node-som.png?branch=master)](https://travis-ci.org/DeepElement/node-som)  \r\n\r\n## Installation\r\n\r\n`npm install node-som`\r\n\r\n## Usage\r\n\r\n```\r\n// Inject the module\r\nvar som = require('node-som');\r\n\r\n// Create the instance\r\nvar somInstance = new som({\r\n\tinputLength: 2,\r\n\tmaxClusters: 5,\r\n\tloggingEnabled: true,\r\n\tscale: {\r\n\t\tmin : 0,\r\n\t\tmax : 1000\r\n\t}\r\n});\r\n\r\n// Train (all automatic). Optionally, you can include custom input vectors, but \r\n// it is recommended that developers allow the automated training (based on the \r\n// `scale` configuration) since this results in better networks\r\nsomInstance.train();\r\n\r\n// Create input array. \r\n// All items features should be normalized to domain [0,1]\r\nvar sample = [0.24, 0.34];\r\n\r\n// Call classify to receive your classification group/neuron\r\nvar group = somInstance.classify(sample);\r\n\r\n// For the sake of intelligence, you can then extract your \r\n// domain boundaries from a stored group by component.\r\nvar groupDomainBoundaries = somInstance.extract(group);\r\n\r\n// The output is enough to do some pretty hardcore analysis on\r\n// the cluster domain (wisker plot, etc)\r\n//\r\n// groupDomainBoundaries = [ \r\n//  { range: [ 0.002023763954639435, 999.9967189505696 ],\r\n//    amean: 498.7489069010919,\r\n//    gmean: 366.71135268678785,\r\n//    median: 498.73221735469997,\r\n//    stddev: 287.81665907708333,\r\n//    gstddev: 2.7296960810401862,\r\n//    moe: 1.7839061347985679 },\r\n//  { range: [ 0.0025222543627023697, 999.9986472539604 ],\r\n//    amean: 501.4137114080192,\r\n//    gmean: 370.21158812427205,\r\n//    median: 500.92090992257,\r\n//    stddev: 288.3074606679444,\r\n//    gstddev: 2.6996348342872674,\r\n//    moe: 1.7869481545750234 } ]\r\n\r\n\r\n```\r\n\r\n## Options\r\n###loggingEnabled (bool)\r\nEnables/Disables logging on the console\r\n\r\n###maxClusters (Integer) \r\nMax number of Classification groups to use. This is an upper-bound and an optimized network usually contains less than this number.\r\n\r\n###created (Date) \r\nWhen the network was initially created\r\n\r\n###classificationCount (Integer) \r\nRepresents the number of classifications run through the network. Used as a metric of maturity.\r\n\r\n###inputLength (Integer) \r\nComponent length of input vectors\r\n\r\n###inputPatterns (Integer) \r\nRepresents the number of random samples to self-train on. Higher numbers cost more, but can result in more granular groups\r\n\r\n###scale (Complex) \r\nTells the SOM how to train to insure high accuracy on the target domain. ex. {min: -1000, max: 1000}\r\n\r\n## API\r\n\r\n###train \r\nAccepts an array of unscaled input vectors of ordinal length `inputLength`. The implementation scales itself, based on the `scale` constructor configuration.\r\n\r\nIf no training vectors are provided, Recommended, a random set is generated and trained based on the `__inputPatterns__` configuration. \r\n\r\n_Note: this results in the most optimized network_\r\n\r\n###classify\r\nGiven a single unscaled input vector, will return the classification/neuron that best describes the input based on the network state\r\n\r\n###extract\r\nGiven a classication/neuron, will return component statistics for unscaled input vector extraction. Statistics are in the form of component ranges.\r\n\r\nIts up to the developer to use this information to infer about their own domain, since the network doesn't hold on to the entire input domain upon training/classification (for momento purposes).\r\n\r\n###serialize\r\nSerialize the network for future use. \r\n\r\nReloading the network can be done by passing the serialized json into the constructor on instantiation. \r\n\r\n###scaleInput\r\nScales a vector of `inputLength` based on the SOM's `scale` boundaries. \r\n\r\n_Note: scaling is done internally. No need to do this unless extending the network implementation _\r\n\r\n###descaleInput\r\n Descales a scalled vector of `inputLength` based on the SOM's `scale` boundaries.\r\n\r\n_Note: descaling is done internally. No need to do this unless extending the network implementation.  _\r\n\r\n\r\n#Samples\r\n## Colors Clustering\r\nThis example shows how the SOM can adaptively cluster a random RGB input space based on the network's training state. \r\n\r\nrun `node examples/colors/colors-cluster.js` from the root of the application.\r\n\r\nAfter the batch script has completed running, open the resulting html file with `open examples/colors/color.html`\r\n","google":"UA-18193655-5","note":"Don't delete this file! It's used internally to help with page regeneration."}